"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Browser_instances, _Browser_client, _Browser_cookieJar, _Browser_fkey, _Browser_userId, _Browser_userName, _Browser_times, _Browser_loadFKey, _Browser_loadUser, _Browser_updateChatFKeyAndUser, _Browser_forceAbsoluteURL, _Browser_request, _Browser_get$, _Browser_post, _Browser_postKeyed, _Browser_getCookie, _Browser_scrapeFkey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Browser = exports.DeleteMessageStatus = void 0;
const cheerio = __importStar(require("cheerio"));
const got_1 = __importDefault(require("got"));
const tough_cookie_1 = require("tough-cookie");
const url_1 = require("url");
const ws_1 = __importDefault(require("ws"));
const Client_1 = require("./Client");
const ChatExchangeError_1 = __importDefault(require("./Exceptions/ChatExchangeError"));
const LoginError_1 = __importDefault(require("./Exceptions/LoginError"));
const ScrapingError_1 = __importDefault(require("./Exceptions/ScrapingError"));
const Message_1 = __importDefault(require("./Message"));
const User_1 = __importDefault(require("./User"));
const utils_1 = require("./utils");
got_1.default.extend({
    followRedirect: false,
    headers: { "User-Agent": "Node.js/ChatExchange" },
    decompress: true,
});
var DeleteMessageStatus;
(function (DeleteMessageStatus) {
    DeleteMessageStatus[DeleteMessageStatus["SUCCESS"] = 0] = "SUCCESS";
    DeleteMessageStatus[DeleteMessageStatus["TOO_OLD"] = 1] = "TOO_OLD";
    DeleteMessageStatus[DeleteMessageStatus["DELETED"] = 2] = "DELETED";
    DeleteMessageStatus[DeleteMessageStatus["UNKNOWN"] = 4] = "UNKNOWN";
})(DeleteMessageStatus = exports.DeleteMessageStatus || (exports.DeleteMessageStatus = {}));
/**
 * Used internally by {@link Client} to provide the low-level
 * interaction with SE servers.
 *
 * @class Browser
 * @property {boolean} loggedIn User logged in
 */
class Browser {
    constructor(client) {
        _Browser_instances.add(this);
        this.loggedIn = false;
        _Browser_client.set(this, void 0);
        _Browser_cookieJar.set(this, void 0);
        _Browser_fkey.set(this, void 0);
        _Browser_userId.set(this, void 0);
        _Browser_userName.set(this, void 0);
        /**
         * @private
         * @summary internal <roomId, time> Map (needed for watchRoom)
         */
        _Browser_times.set(this, new Map());
        __classPrivateFieldSet(this, _Browser_client, client, "f");
        __classPrivateFieldSet(this, _Browser_cookieJar, new tough_cookie_1.CookieJar(), "f");
        client.browser = this;
    }
    /**
     * @summary getter for login host domain name
     * @returns {string}
     * @memberof Browser#
     */
    get loginHost() {
        const { host } = __classPrivateFieldGet(this, _Browser_client, "f");
        return host === "stackexchange.com" ? "meta.stackexchange.com" : host;
    }
    /**
     * @summary proxy getter for the chat host URL
     * @returns {string}
     * @memberof Browser#
     */
    get root() {
        return __classPrivateFieldGet(this, _Browser_client, "f").root;
    }
    /**
     * @summary The chat key for use with ws-auth, and other authy endpoints
     * @returns {Promise<string>}
     * @memberof Browser#
     */
    get chatFKey() {
        return (0, utils_1.lazy)(() => __classPrivateFieldGet(this, _Browser_fkey, "f"), () => __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_updateChatFKeyAndUser).call(this));
    }
    /**
     * @summary The user id of the logged in user
     * @returns {Promise<number>}
     * @memberof Browser#
     */
    get userId() {
        return (0, utils_1.lazy)(() => __classPrivateFieldGet(this, _Browser_userId, "f"), () => __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_updateChatFKeyAndUser).call(this));
    }
    /**
     * @summary The user name of the logged in user
     * @returns {Promise<string>}
     * @memberof Browser#
     */
    get userName() {
        return (0, utils_1.lazy)(() => __classPrivateFieldGet(this, _Browser_userName, "f"), () => __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_updateChatFKeyAndUser).call(this));
    }
    /**
     * Attempts to login to stack exchange, using the provided
     * cookie jar string, which was retrieved from the {@Link Browser#login}
     * method.
     *
     * @param {string|CookieJar.Serialized} cookie A cookie jar string
     * @returns {Promise<void>} A promise that completes with the user logs in
     * @memberof Browser#
     */
    async loginCookie(cookie) {
        __classPrivateFieldSet(this, _Browser_cookieJar, tough_cookie_1.CookieJar.deserializeSync(cookie), "f");
        const [, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, `https://${__classPrivateFieldGet(this, _Browser_client, "f").host}/`);
        const res = $("input[name=fkey]:not([value=''])");
        if (res.length === 0) {
            throw new LoginError_1.default("Login with acct string could not be verified, try credential login instead.", { cookie });
        }
        this.loggedIn = true;
    }
    /**
     * Attempts to login to stack exchange, using the provided
     * email and password. Returns a cookie jar string, which
     * you can pass back in to loginCookieJar for use with further
     * logins.
     *
     * @param {string} email Email
     * @param {string} password Password
     * @returns {Promise<string>} A cookie jar containing account pertitent details.
     * @memberof Browser#
     */
    async login(email, password) {
        const { loginHost } = this;
        const loginUrl = `https://${loginHost}/users/login`;
        const fkey = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_scrapeFkey).call(this, "users/login");
        await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_post).call(this, loginUrl, { data: { email, fkey, password }, type: "text" });
        const acctCookie = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_getCookie).call(this, "acct");
        if (typeof acctCookie === "undefined") {
            throw new LoginError_1.default("failed to get acct cookie from Stack Exchange OpenID, check creds provided for accuracy", { email, password });
        }
        this.loggedIn = true;
        return JSON.stringify(__classPrivateFieldGet(this, _Browser_cookieJar, "f"));
    }
    /**
     * @summary attempts to logout from the Stack Exchange network
     * @returns {Promise<boolean>} status of the logout attempt
     * @memberof Browser#
     */
    async logout() {
        const { loginHost } = this;
        const logoutUrl = `https://${loginHost}/users/logout`;
        const fkey = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_scrapeFkey).call(this, "users/logout");
        const res = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_post).call(this, logoutUrl, { data: { fkey }, type: "text" });
        return (this.loggedIn = res.statusCode === 200);
    }
    /**
     * @summary attempts to create a {@link Room}
     * @param config room configuration options
     */
    async createRoom(config) {
        const { tags = [], defaultAccess = "read-write" } = config;
        const res = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, "rooms/save", {
            data: Object.assign(Object.assign({}, config), { host: `chat.${config.host}`, defaultAccess, noDupeCheck: true, tags: tags.join(" ") }),
        });
        // this is not a mistake
        if (res.statusCode !== 302 || !res.headers.location) {
            throw new ChatExchangeError_1.default("failed to create a room");
        }
        const [, roomId] = res.headers.location.match(/rooms\/info\/(\d+)/) || [];
        const numericRoomId = +roomId;
        if (!numericRoomId) {
            throw new ChatExchangeError_1.default("failed to get created room id");
        }
        return numericRoomId;
    }
    /**
     * @summary attempts to update a {@link Room}
     * @param roomId id of the room to update
     * @param config room configuration options
     */
    async updateRoom(roomId, config) {
        const { tags = [], defaultAccess = "read-write" } = config;
        const res = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, "rooms/save", {
            data: Object.assign(Object.assign({}, config), { host: `chat.${config.host}`, defaultAccess, noDupeCheck: true, tags: tags.join(" ") }),
        });
        // this is not a mistake
        if (res.statusCode !== 302 || !res.headers.location) {
            throw new ChatExchangeError_1.default("failed to update a room");
        }
        return roomId;
    }
    /**
     * @summary Joins a given room
     * @param room The room or room ID to join
     * @returns {Promise<boolean>} A promise that resolves when the user has successfully joined the room
     * @memberof Browser#
     */
    async joinRoom(room) {
        const id = typeof room === "number" ? room : room.id;
        const { body, statusCode } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, `chats/${id}/events`, {
            data: {
                mode: "Messages",
                msgCount: 100,
                since: 0,
            }
        });
        // https://github.com/samliew/chatexchange/issues/207
        const parsedBody = typeof body === "string" ? JSON.parse(body) : body;
        const { time } = parsedBody;
        __classPrivateFieldGet(this, _Browser_times, "f").set(id, time);
        return statusCode === 200;
    }
    /**
     * @summary Leaves a given room
     * @param room The room or room ID to leave
     * @returns {Promise<boolean>} A promise that resolves when the user leaves the room
     * @memberof Browser#
     */
    async leaveRoom(room) {
        const id = typeof room === "number" ? room : room.id;
        const { statusCode } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, `chats/leave/${id}`, { data: { quiet: true } });
        const isSuccess = statusCode === 200;
        if (isSuccess)
            __classPrivateFieldGet(this, _Browser_times, "f").delete(id);
        return isSuccess;
    }
    /**
     * @summary Leaves all rooms
     * @returns {Promise<boolean>} A promise resolving when the user leaves all rooms
     * @memberof Browser#
     */
    async leaveAllRooms() {
        const { statusCode } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, `chats/leave/all`, { data: { quiet: true } });
        const isSuccess = statusCode === 200;
        if (isSuccess)
            __classPrivateFieldGet(this, _Browser_times, "f").clear();
        return isSuccess;
    }
    /**
     * @summary lists users in a given room
     * @param room The room or room ID
     */
    async listUsers(room) {
        const { root } = this;
        const roomid = typeof room === "number" ? room : room.id;
        const [, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, `${root}rooms/info/${roomid}`, {
            params: {
                id: roomid,
                tag: "general",
                users: "current",
            }
        });
        const client = __classPrivateFieldGet(this, _Browser_client, "f");
        const users = [];
        $("#room-usercards .usercard").each((_, card) => {
            var _a, _b, _c;
            const userName = ((_a = $(card).find(".user-header")) === null || _a === void 0 ? void 0 : _a.attr("title")) || "";
            const name = userName.replace(/\s\u2666$/, '');
            const userLink = ((_b = $(card).find(`.user-header a[href*="/users/"]`)) === null || _b === void 0 ? void 0 : _b.attr("href")) || "";
            const [, userId] = /(\d+)/.exec(userLink) || [];
            if (Number.isNaN(+userId))
                return;
            const about = ((_c = $(card).find(".user-message-info")) === null || _c === void 0 ? void 0 : _c.attr("title")) || "";
            const isModerator = !!$(card).find(".user-header .moderator").length;
            users.push(new User_1.default(client, +userId, { about, isModerator, name, }));
        });
        return users;
    }
    /**
     * @summary Watch a room, and returns the websocket
     * @param room The room or room ID to join
     * @returns {Promise<WebSocket>} The websocket of this room
     * @memberof Browser#
     */
    async watchRoom(room) {
        const { root } = this;
        const roomid = typeof room === "number" ? room : room.id;
        const { body } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, "ws-auth", { data: { roomid, } });
        const l = __classPrivateFieldGet(this, _Browser_times, "f").get(roomid);
        if (!l) {
            const entries = [...__classPrivateFieldGet(this, _Browser_times, "f")];
            const report = entries
                .map(([k, v]) => `${k} : ${v || "missing"}`)
                .join("\n");
            throw new ChatExchangeError_1.default(`missing time key for room ${roomid}\n\nTime keys\n${report}`);
        }
        // https://github.com/samliew/chatexchange/issues/207
        const parsedBody = typeof body === "string" ? JSON.parse(body) : body;
        const { url } = parsedBody;
        if (!url) {
            throw new ChatExchangeError_1.default(`missing URL in the ws-auth response:\n${body}`);
        }
        const address = new url_1.URL(url);
        address.searchParams.append("l", l.toString());
        const ws = new ws_1.default(address, { origin: root });
        // simple instantiation of WebSocket does not guarantee its readiness
        // only after the "open" event fires, a WebSocket is ready for data transfer
        // awaiting a promise till this happens ensures the returned WS is ready
        await new Promise((r) => ws.once("open", r));
        return ws;
    }
    /**
     * @summary Fetches a given user's profile
     * @param user The user or user ID to fetch
     * @returns {Promise<IProfileData>} The profile object
     * @memberof Browser#
     */
    async getProfile(user) {
        var _a;
        const userId = typeof user === "number" ? user : user.id;
        const [code, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, `users/${userId}`, { mutedStatusCodes: [404] });
        if (code === 404) {
            throw new ScrapingError_1.default(`failed to get user #${userId}`, $.html());
        }
        const name = $("h1").text();
        const isModerator = $(".user-status").first().text().includes("â™¦");
        const roomCount = Number($(".user-room-count-xxl").text());
        const messageCount = Number($(".user-message-count-xxl").text());
        const repElems = $(".reputation-score");
        const reputation = Number(repElems.attr("title") || "1") || 1;
        const statsCells = $(".user-keycell,.user-valuecell");
        // Filter out only text (Ignore HTML entirely)
        const statsElements = statsCells
            .map((_i, el) => $(el).text().trim().replace(/\s{2,}[\w\s()]*/u, ""))
            .get();
        const { about, "last message": lmsg, "last seen": lseen, } = (0, utils_1.arrayToKvp)(statsElements);
        const lastMessage = lmsg !== void 0 ? (0, utils_1.parseAgoString)(lmsg) : -1;
        const lastSeen = lseen !== void 0 ? (0, utils_1.parseAgoString)(lseen) : -1;
        const profile = {
            about,
            id: userId,
            isModerator,
            lastMessage,
            lastSeen,
            messageCount,
            name,
            reputation,
            roomCount,
        };
        const [parentCell] = statsCells.filter((_, el) => $(el).text().trim() === "parent user");
        const [parentValueCell] = $(parentCell).next();
        const parentHref = (_a = $(parentValueCell).find("a[href*='/users/']").attr("href")) === null || _a === void 0 ? void 0 : _a.trim();
        // https://regex101.com/r/SqNlXB/1
        const parentIdUnparsed = parentHref === null || parentHref === void 0 ? void 0 : parentHref.replace(/.+?\/users\/(\d+).*$/, "$1");
        const parentId = parentIdUnparsed && parseInt(parentIdUnparsed, 10);
        if (parentId)
            profile.parentId = parentId;
        // https://regex101.com/r/Aqx7Qs/3
        const parentSite = parentHref === null || parentHref === void 0 ? void 0 : parentHref.replace(/(?:https?:|^)\/{2}(.+?)\/users.*?$/, "$1");
        const parentHost = (0, Client_1.isAllowedHost)(parentSite) ?
            parentSite :
            // https://regex101.com/r/i6c9zB/1
            parentSite === null || parentSite === void 0 ? void 0 : parentSite.replace(/^.+?\.(?=stackoverflow|stackexchange)/, "");
        profile.parentHost = parentHost;
        profile.parentSite = parentSite;
        return profile;
    }
    /**
     * @summary Scrapes the transcript for a message, and returns the message metadata
     * @param message The message or message ID to scrape
     * @returns {Promise<ITranscriptData>}
     * @memberof Browser#
     */
    async getTranscript(message) {
        var _a, _b, _c, _d;
        const msgId = typeof message === "number" ? message : message.id;
        if (!msgId) {
            throw new ChatExchangeError_1.default("cannot get a transcript of an invalid message");
        }
        const [code, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, `transcript/message/${msgId}`, { mutedStatusCodes: [404] });
        if (code === 404) {
            throw new ScrapingError_1.default(`failed to get message #${msgId}`, $.html());
        }
        const $msg = $(".message.highlight");
        const $room = $(".room-name a");
        const $userDiv = $msg.parent().prev(".signature").find(".username a"); // Possible for $userDiv element to be missing for some reason
        const $monologue = $msg.closest('.monologue'); // Fallback to the monologue element
        const userId = Number((_b = (_a = $userDiv === null || $userDiv === void 0 ? void 0 : $userDiv.attr("href")) === null || _a === void 0 ? void 0 : _a.split("/")[2]) !== null && _b !== void 0 ? _b : (_d = (_c = $monologue === null || $monologue === void 0 ? void 0 : $monologue.attr('class')) === null || _c === void 0 ? void 0 : _c.match(/\d+$/)) === null || _d === void 0 ? void 0 : _d.pop());
        const userName = $userDiv.text();
        const user = __classPrivateFieldGet(this, _Browser_client, "f").getUser(userId, { name: userName });
        const roomName = $room.text();
        const roomId = Number($room.attr("href").split("/")[2]); // eslint-disable-line prefer-destructuring
        const edited = $msg.find(".edits").length > 0;
        const content = $msg.find(".content").text().trim();
        const replyInfo = $msg.find(".reply-info");
        let parentMessageId;
        if (replyInfo.length > 0) {
            parentMessageId = Number(replyInfo.attr("href").split("#")[1]);
        }
        return {
            content,
            edited,
            id: msgId,
            parentMessageId,
            roomId,
            roomName,
            user,
        };
    }
    /**
     * @summary Deletes a message
     * @param {number} messageId ID of the message to delete
     */
    async deleteMessage(messageId) {
        const { host } = __classPrivateFieldGet(this, _Browser_client, "f");
        const { body } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, `https://chat.${host}/messages/${messageId}/delete`, { type: "text" });
        const statusMap = {
            "ok": DeleteMessageStatus.SUCCESS,
            "It is too late to delete this message": DeleteMessageStatus.TOO_OLD,
            "This message has already been deleted.": DeleteMessageStatus.DELETED
        };
        return statusMap[body] !== void 0 ?
            statusMap[body] :
            DeleteMessageStatus.UNKNOWN;
    }
    /**
     * @summary Sends a message to a room
     * @param {number} roomId The room ID to send to
     * @param {string} text The message to send
     * @returns {Promise<Message>} A promise that resolves the message that was sent
     * @memberof Browser#
     */
    async sendMessage(roomId, text) {
        const { body } = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_postKeyed).call(this, `chats/${roomId}/messages/new`, { data: { text } });
        return new Message_1.default(__classPrivateFieldGet(this, _Browser_client, "f"), body.id, { roomId });
    }
}
exports.Browser = Browser;
_Browser_client = new WeakMap(), _Browser_cookieJar = new WeakMap(), _Browser_fkey = new WeakMap(), _Browser_userId = new WeakMap(), _Browser_userName = new WeakMap(), _Browser_times = new WeakMap(), _Browser_instances = new WeakSet(), _Browser_loadFKey = function _Browser_loadFKey($) {
    const fkeySelector = 'input[name="fkey"]';
    const fkey = $(fkeySelector).val();
    __classPrivateFieldSet(this, _Browser_fkey, fkey, "f");
    if (typeof fkey === "undefined") {
        throw new ScrapingError_1.default("Unable to find fkey", $.html(), fkeySelector);
    }
    return fkey;
}, _Browser_loadUser = function _Browser_loadUser($) {
    var _a;
    const userLink = $(".topbar-menu-links a");
    const [, , userId, userName] = ((_a = userLink.attr("href")) === null || _a === void 0 ? void 0 : _a.split("/")) || [];
    const id = Number(userId);
    __classPrivateFieldSet(this, _Browser_userId, id, "f");
    __classPrivateFieldSet(this, _Browser_userName, userName, "f");
    return id;
}, _Browser_updateChatFKeyAndUser = 
/**
 * @private
 *
 * @summary refreshes user fkey and user info
 * @returns {Promise<void>}
 */
async function _Browser_updateChatFKeyAndUser() {
    const [, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, "chats/join/favorite");
    __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_loadFKey).call(this, $);
    __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_loadUser).call(this, $);
}, _Browser_forceAbsoluteURL = function _Browser_forceAbsoluteURL(url) {
    const parsed = new url_1.URL(url, this.root);
    return parsed.toString();
}, _Browser_request = 
/**
 * @private
 *
 * @summary abstract request helper
 * @param url request URL
 * @param config request configuration
 */
async function _Browser_request(url, config) {
    const { data, method = "GET", mutedStatusCodes: muteErrors = [], params, type } = config;
    const options = {
        cookieJar: __classPrivateFieldGet(this, _Browser_cookieJar, "f"),
        method,
        searchParams: params,
    };
    if (type === "json") {
        options.responseType = "json";
    }
    //ensures empty body is not added on GET requests
    if (method.toUpperCase() !== "GET") {
        options.form = data;
    }
    const res = await (0, got_1.default)(__classPrivateFieldGet(this, _Browser_instances, "m", _Browser_forceAbsoluteURL).call(this, url), options);
    const { statusCode } = res;
    if (statusCode >= 400 && !muteErrors.includes(statusCode)) {
        throw new ChatExchangeError_1.default(`Remote server threw ${res.statusCode} error\nURL: ${url}`);
    }
    return res;
}, _Browser_get$ = 
/**
 * @private
 *
 * @summary cheeiro parsed data request helper
 * @param uri request URI
 * @param config request configuration
 */
async function _Browser_get$(uri, config = {}) {
    const res = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_request).call(this, uri, config);
    return [res.statusCode, cheerio.load(res.body)];
}, _Browser_post = function _Browser_post(uri, config) {
    return __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_request).call(this, uri, Object.assign({ method: "post" }, config));
}, _Browser_postKeyed = 
/**
 * @private
 *
 * @summary POST request helper with fkey parameter set
 * @param uri request URI
 * @param confg request configuration
 */
async function _Browser_postKeyed(uri, config) {
    return __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_post).call(this, uri, Object.assign(Object.assign({}, config), { data: Object.assign(Object.assign({}, config.data), { fkey: await this.chatFKey }) }));
}, _Browser_getCookie = 
/**
 * @private
 *
 * @summary gets a cookie by key
 * @param {string} key cookie key
 * @returns {Promise<Cookie>}
 */
async function _Browser_getCookie(key) {
    const cookies = await __classPrivateFieldGet(this, _Browser_cookieJar, "f").getCookies(`https://${__classPrivateFieldGet(this, _Browser_client, "f").host}`);
    return cookies.find((cookie) => cookie.key === key);
}, _Browser_scrapeFkey = 
/**
 * @private
 *
 * @summary gets an fkey value for a given path
 * @param path path on the {@link Browser#loginHost}
 *
 * @throws {ScrapingError} if fkey is missing
 */
async function _Browser_scrapeFkey(path) {
    const { loginHost } = this;
    const url = `https://${loginHost}/${path.replace(/^\//, "")}`;
    const [, $] = await __classPrivateFieldGet(this, _Browser_instances, "m", _Browser_get$).call(this, url);
    const fkeySelector = 'input[name="fkey"]';
    const fkeyElem = $(fkeySelector);
    const fkey = fkeyElem.val();
    if (typeof fkey === "undefined") {
        throw new ScrapingError_1.default(`fkey missing (${path})`, $.html(), fkeySelector);
    }
    return fkey;
};
exports.default = Browser;
