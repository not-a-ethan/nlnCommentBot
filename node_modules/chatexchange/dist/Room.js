"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Room_client, _Room_socket, _Room_ignored, _Room_blocked;
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
const InvalidArgumentError_1 = __importDefault(require("./Exceptions/InvalidArgumentError"));
const utils_1 = require("./utils");
const WebsocketEvent_1 = require("./WebsocketEvent");
/* eslint-disable no-underscore-dangle */
/**
 * Represents a chatroom
 *
 * @extends {EventEmitter}
 */
class Room extends events_1.EventEmitter {
    /**
     * Creates an instance of Room.
     *
     * @param {Client} client The Client instance
     * @param {number} id The id of the room
     * @memberof Room
     */
    constructor(client, id) {
        super();
        this.id = id;
        _Room_client.set(this, void 0);
        _Room_socket.set(this, void 0);
        _Room_ignored.set(this, new Set());
        _Room_blocked.set(this, new Map());
        this.leaving = false;
        __classPrivateFieldSet(this, _Room_client, client, "f");
    }
    /**
     * @summary returns the room's transcript URL
     */
    get transcriptURL() {
        const { host } = __classPrivateFieldGet(this, _Room_client, "f");
        const { id } = this;
        return `https://chat.${host}/transcript/${id}`;
    }
    /**
     * @summary attempts to update the room
     * @param config {@link Room} configuration options
     */
    async update(config) {
        try {
            await __classPrivateFieldGet(this, _Room_client, "f").updateRoom(this, config);
            return true;
        }
        catch (error) {
            console.error(error);
            return false;
        }
    }
    /**
     * Blocks a user for a given amount of time (or forever)
     *
     * @param user user to block
     * @param howLong how long to block the user (in seconds)
     * @returns {void}
     * @memberof Room
     */
    block(user, howLong = Infinity) {
        const uid = typeof user === "number" ? user : user.id;
        __classPrivateFieldGet(this, _Room_blocked, "f").set(uid, howLong);
        if (howLong < Infinity) {
            (0, utils_1.delay)(howLong * 1e3).then(() => this.unblock(uid));
        }
    }
    /**
     * Unblocks users
     *
     * @param users users to unblock
     * @returns {void}
     * @memberof Room
     */
    unblock(...users) {
        users.forEach((u) => {
            const uid = typeof u === "number" ? u : u.id;
            __classPrivateFieldGet(this, _Room_blocked, "f").delete(uid);
        });
    }
    /**
     * Checks if a user is blocked
     *
     * @param user user to check
     * @returns {boolean}
     * @memberof Room
     */
    isBlocked(user) {
        const uid = typeof user === "number" ? user : user.id;
        return __classPrivateFieldGet(this, _Room_blocked, "f").has(uid);
    }
    /**
     * Adds a chat event type to the list of ignored types
     *
     * @param {...ChatEventType} eventType event type
     * @returns {void}
     * @memberof Room
     */
    ignore(...eventType) {
        eventType.forEach((type) => {
            __classPrivateFieldGet(this, _Room_ignored, "f").add(type);
        });
    }
    /**
     * Removes an event type from the list of ignored types
     *
     * @param {...ChatEventType} eventType event type
     * @returns {void}
     * @memberof Room
     */
    unignore(...eventType) {
        eventType.forEach((type) => {
            __classPrivateFieldGet(this, _Room_ignored, "f").delete(type);
        });
    }
    /**
     * Checks if an event type is ignored
     *
     * @param {ChatEventType} eventType event type
     * @returns {boolean}
     * @memberof Room
     */
    isIgnored(eventType) {
        return __classPrivateFieldGet(this, _Room_ignored, "f").has(eventType);
    }
    /**
     * @summary exclusively subscribes to a list of events
     * @param eventType event type
     */
    only(...eventType) {
        const allow = new Set(eventType);
        const ignore = Object.values(WebsocketEvent_1.ChatEventType).filter((v) => !allow.has(v));
        return this.ignore(...ignore);
    }
    /**
     * @summary Join a chat room
     * @returns {Promise<boolean>} A promise when the user succesfully joins this room
     * @memberof Room#
     */
    join() {
        this.leaving = false;
        return __classPrivateFieldGet(this, _Room_client, "f").joinRoom(this);
    }
    /**
     * @summary Leave a chat room
     * @returns {Promise<boolean>} A promise when the user succesfully leaves this room
     * @memberof Room#
     */
    leave() {
        var _a;
        this.leaving = true;
        (_a = __classPrivateFieldGet(this, _Room_socket, "f")) === null || _a === void 0 ? void 0 : _a.close();
        return __classPrivateFieldGet(this, _Room_client, "f").leaveRoom(this);
    }
    /**
     * Connects to the chatroom websocket, and watches
     * for new events
     *
     * @returns {Promise<Room>} A promise that completes when the webscocket connection is successfull.
     * @memberof Room
     */
    async watch() {
        __classPrivateFieldSet(this, _Room_socket, await __classPrivateFieldGet(this, _Room_client, "f").watch(this), "f");
        return this;
    }
    /**
     * @summary deletes a given message
     * @param message {@link Message} or ID to delete
     */
    async delete(message) {
        return __classPrivateFieldGet(this, _Room_client, "f").delete(message);
    }
    /**
     * @summary returns a list of users currently in the room
     */
    async listUsers() {
        return __classPrivateFieldGet(this, _Room_client, "f").listUsers(this);
    }
    /**
     * @summary Sends a message to this room
     * @param message The message to send
     * @throws {InvalidArgumentError} If `content` > 500 character, empty, or isn't a string.
     * @returns {Promise<Message>} A promise with the message that was sent
     * @memberof Room#
     */
    async sendMessage(message) {
        if (typeof message !== "string") {
            throw new InvalidArgumentError_1.default("Message should be a string.");
        }
        if (message.length > 500) {
            throw new InvalidArgumentError_1.default("Unable to send message because it was longer than 500 characters.");
        }
        if (message.length === 0) {
            throw new InvalidArgumentError_1.default("Unable to send message because it was empty.");
        }
        const [, msg] = await __classPrivateFieldGet(this, _Room_client, "f").send(message, this);
        return msg;
    }
}
_Room_client = new WeakMap(), _Room_socket = new WeakMap(), _Room_ignored = new WeakMap(), _Room_blocked = new WeakMap();
exports.default = Room;
