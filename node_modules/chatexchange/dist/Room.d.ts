/// <reference types="node" />
import { EventEmitter } from "events";
import { DeleteMessageStatus, type IRoomSave } from "./Browser.js";
import type Client from "./Client";
import Message from "./Message";
import User from "./User";
import { ChatEventType } from "./WebsocketEvent";
/**
 * Represents a chatroom
 *
 * @extends {EventEmitter}
 */
declare class Room extends EventEmitter {
    #private;
    id: number;
    leaving: boolean;
    /**
     * Creates an instance of Room.
     *
     * @param {Client} client The Client instance
     * @param {number} id The id of the room
     * @memberof Room
     */
    constructor(client: Client, id: number);
    /**
     * @summary returns the room's transcript URL
     */
    get transcriptURL(): string;
    /**
     * @summary attempts to update the room
     * @param config {@link Room} configuration options
     */
    update(config: Omit<IRoomSave, "host">): Promise<boolean>;
    /**
     * Blocks a user for a given amount of time (or forever)
     *
     * @param user user to block
     * @param howLong how long to block the user (in seconds)
     * @returns {void}
     * @memberof Room
     */
    block(user: number | User, howLong?: number): void;
    /**
     * Unblocks users
     *
     * @param users users to unblock
     * @returns {void}
     * @memberof Room
     */
    unblock(...users: (number | User)[]): void;
    /**
     * Checks if a user is blocked
     *
     * @param user user to check
     * @returns {boolean}
     * @memberof Room
     */
    isBlocked(user: number | User): boolean;
    /**
     * Adds a chat event type to the list of ignored types
     *
     * @param {...ChatEventType} eventType event type
     * @returns {void}
     * @memberof Room
     */
    ignore(...eventType: ChatEventType[]): void;
    /**
     * Removes an event type from the list of ignored types
     *
     * @param {...ChatEventType} eventType event type
     * @returns {void}
     * @memberof Room
     */
    unignore(...eventType: ChatEventType[]): void;
    /**
     * Checks if an event type is ignored
     *
     * @param {ChatEventType} eventType event type
     * @returns {boolean}
     * @memberof Room
     */
    isIgnored(eventType: ChatEventType): boolean;
    /**
     * @summary exclusively subscribes to a list of events
     * @param eventType event type
     */
    only(...eventType: ChatEventType[]): void;
    /**
     * @summary Join a chat room
     * @returns {Promise<boolean>} A promise when the user succesfully joins this room
     * @memberof Room#
     */
    join(): Promise<boolean>;
    /**
     * @summary Leave a chat room
     * @returns {Promise<boolean>} A promise when the user succesfully leaves this room
     * @memberof Room#
     */
    leave(): Promise<boolean>;
    /**
     * Connects to the chatroom websocket, and watches
     * for new events
     *
     * @returns {Promise<Room>} A promise that completes when the webscocket connection is successfull.
     * @memberof Room
     */
    watch(): Promise<Room>;
    /**
     * @summary deletes a given message
     * @param message {@link Message} or ID to delete
     */
    delete(message: number | Message): Promise<DeleteMessageStatus>;
    /**
     * @summary returns a list of users currently in the room
     */
    listUsers(): Promise<User[]>;
    /**
     * @summary Sends a message to this room
     * @param message The message to send
     * @throws {InvalidArgumentError} If `content` > 500 character, empty, or isn't a string.
     * @returns {Promise<Message>} A promise with the message that was sent
     * @memberof Room#
     */
    sendMessage(message: string): Promise<Message>;
}
export default Room;
