"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Client_browser, _Client_rooms, _Client_users;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = exports.isAllowedHost = exports.AllowedHosts = void 0;
const email_validator_1 = require("email-validator");
const Browser_1 = __importStar(require("./Browser"));
const ChatExchangeError_1 = __importDefault(require("./Exceptions/ChatExchangeError"));
const InvalidArgumentError_1 = __importDefault(require("./Exceptions/InvalidArgumentError"));
const Message_1 = __importDefault(require("./Message"));
const Room_1 = __importDefault(require("./Room"));
const User_1 = __importDefault(require("./User"));
const utils_1 = require("./utils");
const WebsocketEvent_1 = __importDefault(require("./WebsocketEvent"));
exports.AllowedHosts = [
    "stackexchange.com",
    "meta.stackexchange.com",
    "stackoverflow.com",
];
/**
 * @summary checks if a given host is an allowed {@link Host}
 * @param host host string to check
 */
const isAllowedHost = (host) => {
    return exports.AllowedHosts.some((h) => h === host);
};
exports.isAllowedHost = isAllowedHost;
/**
 * Represents the main chatexchange Client class.
 * @class
 */
class Client {
    /**
     * Creates an instance of Client.
     *
     * @param {string} host The host to connect to (stackexchange.com, meta.stackexchange.com, or stackoverflow.com)
     * @throws {InvalidArgumentError} If the host is invalid
     * @constructor
     */
    constructor(host) {
        this.host = host;
        _Client_browser.set(this, void 0);
        _Client_rooms.set(this, new Map());
        _Client_users.set(this, new Map());
        if (!exports.AllowedHosts.includes(host)) {
            throw new InvalidArgumentError_1.default(`Invalid host. Must be one of ${exports.AllowedHosts.join(", ")}`);
        }
        __classPrivateFieldSet(this, _Client_browser, new Browser_1.default(this), "f");
    }
    /**
     * @summary swaps out the internal {@link Browser} instance
     * @param browser instance of {@link Browser} to swap with
     */
    set browser(browser) {
        __classPrivateFieldSet(this, _Client_browser, browser, "f");
    }
    /**
     * @summary Returns the chat host URL
     * @returns {string}
     * @memberof Client#
     */
    get root() {
        const { host } = this;
        return `https://chat.${host}/`;
    }
    /**
     * @summary gets user chat fkey
     * @returns {Promise<string>}
     * @memberof Client#
     */
    get fkey() {
        return __classPrivateFieldGet(this, _Client_browser, "f").chatFKey;
    }
    /**
     * @summary gets user login status
     */
    get loggedIn() {
        return __classPrivateFieldGet(this, _Client_browser, "f").loggedIn;
    }
    /**
     * Fetches the current logged-in user's profile
     *
     * @returns {Promise<User>} The user object
     * @throws {ChatExchangeError} If no user is currently logged in
     * @memberof Client#
     */
    async getMe() {
        if (!this.loggedIn) {
            throw new ChatExchangeError_1.default("Cannot get user, not logged in.");
        }
        return new User_1.default(this, await __classPrivateFieldGet(this, _Client_browser, "f").userId);
    }
    getMessage(id) {
        // eslint-disable-line class-methods-use-this
        // Add caching in the future?
        return new Message_1.default(this, id);
    }
    getRooms() {
        return __classPrivateFieldGet(this, _Client_rooms, "f");
    }
    getRoomsAsArray() {
        return [...__classPrivateFieldGet(this, _Client_rooms, "f").values()];
    }
    /**
     * @summary gets the chat profile of a given {@link User}
     * @param user user or user ID to get the chat profile of
     */
    getProfile(user) {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        return browser.getProfile(user);
    }
    /**
     * @summary attempts to update a {@link Room}
     * @param config {@link Room} configuration options
     */
    async createRoom(config) {
        const { host } = this;
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        const roomId = await browser.createRoom(Object.assign(Object.assign({}, config), { host }));
        return new Room_1.default(this, roomId);
    }
    /**
     * @summary attempts to update a {@link Room}
     * @param room {@link Room} or {@link Room.id} to update
     * @param config {@link Room} configuration options
     */
    async updateRoom(room, config) {
        const { host } = this;
        const roomId = typeof room === "number" ? room : room.id;
        const broswer = __classPrivateFieldGet(this, _Client_browser, "f");
        const newRoomId = await broswer.updateRoom(roomId, Object.assign(Object.assign({}, config), { host }));
        return new Room_1.default(this, newRoomId);
    }
    /**
     * @summary gets a {@link Room} instance from the client
     * @param room {@link Room} or {@link Room.id} to get
     */
    getRoom(room) {
        const rooms = __classPrivateFieldGet(this, _Client_rooms, "f");
        const isId = typeof room === "number";
        const roomId = isId ? room : room.id;
        const existingRoom = rooms.get(roomId);
        if (existingRoom) {
            return existingRoom;
        }
        const newRoom = isId ? new Room_1.default(this, roomId) : room;
        rooms.set(roomId, newRoom);
        return newRoom;
    }
    /**
     * @summary gets a given chat message transcript info
     * @param message message or message ID to get the transcript for
     */
    getTranscript(message) {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        return browser.getTranscript(message);
    }
    getUser(id, existingData) {
        let user = __classPrivateFieldGet(this, _Client_users, "f").get(id);
        if (user) {
            return user;
        }
        user = new User_1.default(this, id, existingData);
        __classPrivateFieldGet(this, _Client_users, "f").set(id, user);
        return user;
    }
    /**
     * @summary lists users in a given {@link room}
     * @param room room or room ID to list current users from
     */
    async listUsers(room) {
        return __classPrivateFieldGet(this, _Client_browser, "f").listUsers(room);
    }
    /**
     * Attempts to login to the stackexchange network
     * with the provided username and password
     *
     * @param {string} email Email
     * @param {string} password Password
     * @returns {Promise<string>} Request Cookie Jar (Optionally to save to `loginCookie`)
     * @memberof Client#
     */
    async login(email, password) {
        if (!password) {
            throw new InvalidArgumentError_1.default("Email and password are required.");
        }
        if (!(0, email_validator_1.validate)(email))
            throw new InvalidArgumentError_1.default("Invalid email");
        return __classPrivateFieldGet(this, _Client_browser, "f").login(email, password);
    }
    /**
     * @summary attempts to logout from the Stack Exchange network
     * @returns {Promise<boolean>} status of the logout
     * @memberof Client#
     */
    async logout() {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        return !browser.loggedIn || browser.logout();
    }
    /**
     * Attempts to login to stack exchange, using the provided
     * cookie jar string, which was retrieved from the `login`
     * method.
     *
     * @param {string} cookieString A cookie jar string
     * @returns {Promise<void>} A promise representing when login is complete
     * @memberof Client#
     */
    async loginCookie(cookieString) {
        if (typeof cookieString !== "string" || cookieString === "") {
            throw new InvalidArgumentError_1.default("cookieString is required.");
        }
        return __classPrivateFieldGet(this, _Client_browser, "f").loginCookie(cookieString);
    }
    /**
     * @summary Joins a given room
     * @param room The room or ID to join
     * @returns {Promise<boolean>}
     * @memberof Client#
     */
    async joinRoom(room) {
        return __classPrivateFieldGet(this, _Client_browser, "f").joinRoom(this.getRoom(room));
    }
    /**
     * @summary Leaves a given room
     * @param room The {@link Room} or ID to leave
     * @returns {Promise<boolean>}
     */
    async leaveRoom(room) {
        const roomToLeave = this.getRoom(room);
        const status = await __classPrivateFieldGet(this, _Client_browser, "f").leaveRoom(roomToLeave);
        if (status)
            __classPrivateFieldGet(this, _Client_rooms, "f").delete(roomToLeave.id);
        return status;
    }
    /**
     * @summary Leaves all rooms (on same chat server)
     * @returns {Promise<boolean>}
     * @memberof Client#
     */
    leaveAll() {
        return __classPrivateFieldGet(this, _Client_browser, "f").leaveAllRooms();
    }
    /**
     * Broadcasts a message to all joined rooms
     * @param message message to broadcast
     */
    async broadcast(message) {
        const rooms = __classPrivateFieldGet(this, _Client_rooms, "f");
        const statusMap = new Map();
        let throttled = false;
        for (const [roomId, room] of rooms) {
            try {
                await room.sendMessage(message);
                statusMap.set(roomId, true);
                // second message can be sent immediately
                // https://meta.stackexchange.com/a/167749/786798
                if (throttled) {
                    // respect the stated delay between messages
                    // https://meta.stackexchange.com/a/164900/786798
                    await (0, utils_1.delay)(1e3 + 4);
                    throttled = false;
                    continue;
                }
                throttled = true;
            }
            catch (error) {
                statusMap.set(roomId, false);
            }
        }
        return statusMap;
    }
    /**
     * @summary deletes a given message
     * @param message {@link Message} or ID to delete
     */
    async delete(message) {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        const messageId = typeof message === "number" ? message : message.id;
        if (!messageId)
            return Browser_1.DeleteMessageStatus.UNKNOWN;
        return browser.deleteMessage(messageId);
    }
    /**
     * @summary sends a message to a given room
     * @param message message to send
     * @param room room or room ID to send to
     */
    async send(message, room) {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        const roomId = typeof room === "number" ? room : room.id;
        const msg = await browser.sendMessage(roomId, message);
        return [true, msg];
    }
    /**
     * @summary watches a given {@link Room} for new events
     * @param room room or room ID to watch
     */
    async watch(room) {
        const browser = __classPrivateFieldGet(this, _Client_browser, "f");
        const watched = typeof room === "number" ? this.getRoom(room) : room;
        const ws = await browser.watchRoom(watched);
        ws.on("message", (rawMsg) => {
            var _a;
            const json = JSON.parse(rawMsg.toString());
            if (typeof ((_a = json[`r${watched.id}`]) === null || _a === void 0 ? void 0 : _a.e) === "undefined") {
                return;
            }
            const events = json[`r${watched.id}`].e;
            for (const event of events) {
                const msg = new WebsocketEvent_1.default(this, event);
                const skipRules = [
                    watched.isIgnored(msg.eventType),
                    msg.userId && watched.isBlocked(msg.userId),
                ];
                if (skipRules.some(Boolean))
                    continue;
                watched.emit("message", msg);
            }
        });
        ws.on("close", () => {
            if (watched.leaving) {
                watched.emit("close");
            }
            else {
                ws.removeAllListeners();
                watched.watch();
            }
        });
        return ws;
    }
}
exports.Client = Client;
_Client_browser = new WeakMap(), _Client_rooms = new WeakMap(), _Client_users = new WeakMap();
exports.default = Client;
