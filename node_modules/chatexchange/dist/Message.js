"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Message_instances, _Message_client, _Message_room, _Message_transcriptData, _Message_scrapeTranscript;
Object.defineProperty(exports, "__esModule", { value: true });
const ChatExchangeError_1 = __importDefault(require("./Exceptions/ChatExchangeError"));
const utils_1 = require("./utils");
/**
 * Represents a message that was sent in a chatroom
 * @class
 */
class Message {
    /**
     * @summary Creates an instance of Message.
     * @param {Client} client The client associated with this message (undefined if not a message type)
     * @param {number|undefined} id The ID of the message
     * @param {Partial<ITranscriptData>} attrs Extra attributes that should be assigned to this message
     * @constructor
     */
    constructor(client, id, attrs = {}) {
        this.id = id;
        _Message_instances.add(this);
        _Message_client.set(this, void 0);
        _Message_room.set(this, void 0);
        _Message_transcriptData.set(this, void 0);
        __classPrivateFieldSet(this, _Message_client, client, "f");
        __classPrivateFieldSet(this, _Message_transcriptData, attrs, "f");
    }
    /**
     * The room associated with this message
     *
     * @readonly
     * @type {Promise<Room>}
     * @memberof Message
     */
    get room() {
        return (0, utils_1.lazy)(() => __classPrivateFieldGet(this, _Message_room, "f"), 
        /* istanbul ignore next */
        () => this._setRoom());
    }
    /**
     * The room ID associated with this message
     *
     * @readonly
     * @type {Promise<number>}
     * @memberof Message
     */
    get roomId() {
        return (0, utils_1.lazy)(() => { var _a; return (_a = __classPrivateFieldGet(this, _Message_transcriptData, "f")) === null || _a === void 0 ? void 0 : _a.roomId; }, () => __classPrivateFieldGet(this, _Message_instances, "m", _Message_scrapeTranscript).call(this));
    }
    /**
     * The actual text content of the message. This will be raw HTML as
     * parsed by the server
     *
     * @readonly
     * @type {Promise<string>}
     * @memberof Message
     */
    get content() {
        return (0, utils_1.lazy)(() => { var _a; return (_a = __classPrivateFieldGet(this, _Message_transcriptData, "f")) === null || _a === void 0 ? void 0 : _a.content; }, () => __classPrivateFieldGet(this, _Message_instances, "m", _Message_scrapeTranscript).call(this));
    }
    /**
     * The user associated with this message
     *
     * @readonly
     * @type {Promise<User>}
     * @memberof Message
     */
    get user() {
        return (0, utils_1.lazy)(() => { var _a; return (_a = __classPrivateFieldGet(this, _Message_transcriptData, "f")) === null || _a === void 0 ? void 0 : _a.user; }, () => __classPrivateFieldGet(this, _Message_instances, "m", _Message_scrapeTranscript).call(this));
    }
    get parentMessageId() {
        return (0, utils_1.lazy)(() => { var _a; return (_a = __classPrivateFieldGet(this, _Message_transcriptData, "f")) === null || _a === void 0 ? void 0 : _a.parentMessageId; }, () => __classPrivateFieldGet(this, _Message_instances, "m", _Message_scrapeTranscript).call(this));
    }
    async _setRoom() {
        const roomId = await this.roomId;
        __classPrivateFieldSet(this, _Message_room, __classPrivateFieldGet(this, _Message_client, "f").getRoom(roomId), "f");
    }
    /**
     * Send a reply to this message, replying to the user
     * (This will ping the user)
     *
     * @param {string} message The message to send
     * @returns {Promise<Message>} A promise that contains the Message object that was sent
     * @throws {InvalidArgumentError} If message > 500 character, empty, or isn't a string.
     * @memberof Message
     */
    async reply(message) {
        if (!this.id) {
            throw new ChatExchangeError_1.default("This is not a valid message that can be replied to.");
        }
        const room = await this.room;
        const res = await room.sendMessage(`:${this.id} ${message}`);
        return res;
    }
    /**
     * Fetches the parent message from this message, or undefined
     * if there is no message
     *
     * @returns {Promise<Message|undefined>} Promise
     * @memberof Message
     */
    async parent() {
        const parentId = await this.parentMessageId;
        //TODO: rethink - is 0 really the best option when no parent is present?
        if (parentId) {
            return new Message(__classPrivateFieldGet(this, _Message_client, "f"), parentId);
        }
    }
}
_Message_client = new WeakMap(), _Message_room = new WeakMap(), _Message_transcriptData = new WeakMap(), _Message_instances = new WeakSet(), _Message_scrapeTranscript = async function _Message_scrapeTranscript() {
    if (!this.id) {
        throw new ChatExchangeError_1.default("This is not a valid message.");
    }
    __classPrivateFieldSet(this, _Message_transcriptData, await __classPrivateFieldGet(this, _Message_client, "f").getTranscript(this), "f");
};
exports.default = Message;
