/// <reference types="ws" />
import Browser, { DeleteMessageStatus, IRoomSave, type IProfileData, type ITranscriptData } from "./Browser";
import Message from "./Message";
import Room from "./Room";
import User from "./User";
export declare type Host = "stackexchange.com" | "meta.stackexchange.com" | "stackoverflow.com";
export declare const AllowedHosts: Host[];
/**
 * @summary checks if a given host is an allowed {@link Host}
 * @param host host string to check
 */
export declare const isAllowedHost: (host?: string | undefined) => host is Host;
/**
 * Represents the main chatexchange Client class.
 * @class
 */
export declare class Client {
    #private;
    readonly host: Host;
    /**
     * Creates an instance of Client.
     *
     * @param {string} host The host to connect to (stackexchange.com, meta.stackexchange.com, or stackoverflow.com)
     * @throws {InvalidArgumentError} If the host is invalid
     * @constructor
     */
    constructor(host: Host);
    /**
     * @summary swaps out the internal {@link Browser} instance
     * @param browser instance of {@link Browser} to swap with
     */
    set browser(browser: Browser);
    /**
     * @summary Returns the chat host URL
     * @returns {string}
     * @memberof Client#
     */
    get root(): string;
    /**
     * @summary gets user chat fkey
     * @returns {Promise<string>}
     * @memberof Client#
     */
    get fkey(): Promise<string>;
    /**
     * @summary gets user login status
     */
    get loggedIn(): boolean;
    /**
     * Fetches the current logged-in user's profile
     *
     * @returns {Promise<User>} The user object
     * @throws {ChatExchangeError} If no user is currently logged in
     * @memberof Client#
     */
    getMe(): Promise<User>;
    getMessage(id: number): Message;
    getRooms(): Map<number, Room>;
    getRoomsAsArray(): Room[];
    /**
     * @summary gets the chat profile of a given {@link User}
     * @param user user or user ID to get the chat profile of
     */
    getProfile(user: number | User): Promise<IProfileData>;
    /**
     * @summary attempts to update a {@link Room}
     * @param config {@link Room} configuration options
     */
    createRoom(config: Omit<IRoomSave, "host">): Promise<Room>;
    /**
     * @summary attempts to update a {@link Room}
     * @param room {@link Room} or {@link Room.id} to update
     * @param config {@link Room} configuration options
     */
    updateRoom(room: number | Room, config: Omit<IRoomSave, "host">): Promise<Room>;
    /**
     * @summary gets a {@link Room} instance from the client
     * @param room {@link Room} or {@link Room.id} to get
     */
    getRoom(room: number | Room): Room;
    /**
     * @summary gets a given chat message transcript info
     * @param message message or message ID to get the transcript for
     */
    getTranscript(message: number | Message): Promise<ITranscriptData>;
    getUser(id: number, existingData?: Omit<Partial<IProfileData>, "id"> | undefined): User;
    /**
     * @summary lists users in a given {@link room}
     * @param room room or room ID to list current users from
     */
    listUsers(room: number | Room): Promise<User[]>;
    /**
     * Attempts to login to the stackexchange network
     * with the provided username and password
     *
     * @param {string} email Email
     * @param {string} password Password
     * @returns {Promise<string>} Request Cookie Jar (Optionally to save to `loginCookie`)
     * @memberof Client#
     */
    login(email: string, password: string): Promise<string>;
    /**
     * @summary attempts to logout from the Stack Exchange network
     * @returns {Promise<boolean>} status of the logout
     * @memberof Client#
     */
    logout(): Promise<boolean>;
    /**
     * Attempts to login to stack exchange, using the provided
     * cookie jar string, which was retrieved from the `login`
     * method.
     *
     * @param {string} cookieString A cookie jar string
     * @returns {Promise<void>} A promise representing when login is complete
     * @memberof Client#
     */
    loginCookie(cookieString: string): Promise<void>;
    /**
     * @summary Joins a given room
     * @param room The room or ID to join
     * @returns {Promise<boolean>}
     * @memberof Client#
     */
    joinRoom(room: number | Room): Promise<boolean>;
    /**
     * @summary Leaves a given room
     * @param room The {@link Room} or ID to leave
     * @returns {Promise<boolean>}
     */
    leaveRoom(room: number | Room): Promise<boolean>;
    /**
     * @summary Leaves all rooms (on same chat server)
     * @returns {Promise<boolean>}
     * @memberof Client#
     */
    leaveAll(): Promise<boolean>;
    /**
     * Broadcasts a message to all joined rooms
     * @param message message to broadcast
     */
    broadcast(message: string): Promise<Map<number, boolean>>;
    /**
     * @summary deletes a given message
     * @param message {@link Message} or ID to delete
     */
    delete(message: number | Message): Promise<DeleteMessageStatus>;
    /**
     * @summary sends a message to a given room
     * @param message message to send
     * @param room room or room ID to send to
     */
    send(message: string, room: number | Room): Promise<[boolean, Message]>;
    /**
     * @summary watches a given {@link Room} for new events
     * @param room room or room ID to watch
     */
    watch(room: number | Room): Promise<import("ws")>;
}
export default Client;
